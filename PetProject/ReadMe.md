<p align="center">
  <img src="/assets/logo.png" alt="logo" title="Летняя стажировка fuse8/byteminds"/>
</p>

# Задание к уроку №5
**К заданию можно приступить только после проверки предыдущего задания**
- Подлить предыдущее задание в ветку `main`
- Перенести созданный солюшен вместе с решением в папку `PetProject`
- Закоммитить это в `main` (**Самостоятельно**. НЕ нужно для этого создавать PR и ждать апрува от нас)
- От этого коммита начать ветку для решения данного домашним заданием
- Выполнять задание нужно в солюшене, которые вы перенесли в папку `PetProject`

Таким образом мы сможем увидеть изменения, которые произошли в вашем проекте после выполнения данного задания

## InternalApi
- В решении `CurrencyApi` добавить новый проект - `InternalApi`
- Настроить проект `InternalApi`, аналогично `PublicApi` из предыдущего задания (настроить логирование, настроить сваггер)
- **Убедиться, что файл `appsettings.Development.json` не попадает в репозиторий.** В этом файле, как и прежде стоит хранить ключ авторизации.
- Перенести в `InternalApi` реализацию взаимодействия с внешним API из предыдущего задания 
- Доработать этот сервис, чтобы он реализовал интерфейс [ICurrencyAPI](Contracts%2FICurrencyAPI.cs)
  ```csharp
  interface ICurrencyAPI
  {
    Task<Currency[]> GetAllCurrentCurrenciesAsync(string baseCurrency, CancellationToken cancellationToken);
  
    Task<CurrenciesOnDate> GetAllCurrenciesOnDateAsync(string baseCurrency, DateOnly date, CancellationToken cancellationToken);
  }
  ```
- Реализовать кэширующий сервис, который реализует интерфейс [ICachedCurrencyAPI](Contracts%2FICachedCurrencyAPI.cs)
  ```csharp
  interface ICachedCurrencyAPI
  {
    Task<CurrencyDTO> GetCurrentCurrencyAsync(CurrencyType currencyType, CancellationToken cancellationToken);

    Task<CurrencyDTO> GetCurrencyOnDateAsync(CurrencyType currencyType, DateOnly date, CancellationToken cancellationToken);
  }

  ```
  - Сервис `ICachedCurrencyAPI` должен обращаться к методам `ICurrencyAPI` только если в его кэше нет данных либо данные устарели.
  - В качестве кэша нужно использовать сохранение данных на диск. 
  - Формат и способ сохранения на диск не важен, например, можно [использовать JSON](https://learn.microsoft.com/ru-ru/dotnet/standard/serialization/system-text-json/how-to?pivots=dotnet-8-0#how-to-write-net-objects-as-json-serialize).
  - Формат имени файла сделать такой, чтобы по нему можно было определить дату.
  - **Файлы кэша НЕ должны попадать в репозиторий**
  - Время устаревания кэша для `ICachedCurrencyAPI.GetCurrentCurrencyAsync` - 2 часа. 
    То есть, вы должны найти файл с максимальной датой.
    Если дата отличается от текущей меньше чем на 2 часа, то вернуть из метода значение из файла.
    Если сохраненного файла нет или дата отличается больше чем на 2 часа, то выполнить метод сервиса `ICurrencyAPI` и сохранить данные на диск. 
    В качестве даты для имени файла нужно использовать текущую дату со временем
  - Для проверки устаревания кэша для `ICachedCurrencyAPI.GetCurrencyOnDateAsync` должен находить файл с той же датой, для которой делают запрос. 
    Выбирать файлы следует без учета времени. 
    То есть если есть файл полученный 27 июля в 12:43 и файл полученный 27 июля в 18:19 то оба файла попадают под выборку.
    Если файл с данной датой один, то вернуть из метода данные из этого файла.
    Если файлов несколько, то вернуть данные из файла, у которого самое большое время.
    Если файлов с данной датой нет, то выполнить метод сервиса `ICurrencyAPI` и сохранить данные на диск. 
    В качестве даты для имени файла нужно использовать дату `CurrencyOnDateDTO.LastUpdatedAt`
  - Методы `ICachedCurrencyAPI` должны использовать единый кэш. 
  То есть, если 27 июля был вызван метод `ICachedCurrencyAPI.GetCurrentCurrencyAsync` и он добавил файл `27 июля в 18:19`, 
  то при вызове метода `ICachedCurrencyAPI.GetCurrencyOnDateAsync("27 июля")` вернутся данные из этого файла без дополнительного запроса к API.

- Добавить `.proto` файл с описанием grpc сервиса для выполнения следующих действий
  - Получить текущий курс определенной валюты 
  - Получить курс определенной валюты на конкретную дату
  - Получить настройки 
    - Базовая валюта
    - Есть ли еще доступные запросы (`bool value = requestLimit > requestCount`)
- Сгенерировать `gRPC-сервис` по созданному `.proto` (только сервер, без клиента) и добавить реализацию методов
  - Методы `gRPC-сервиса` должны вызывать методы сервиса `ICachedCurrencyAPI` 
  - `gRPC-сервис` должен преобразовывать модели, которые возвращает `ICachedCurrencyAPI` в свои модели (которые сгенерированы по `.proto`)
- Сделать `REST-API` в проекте `InternalApi`, который будет повторять методы `gRCP-сервиса` и дополнительно реализовывать хелсчек
- Все контроллеры, экшены, модели должны иметь описание
- При запуске приложение открывает два порта. Один использовать для gRPC, второй для REST-апи.
- Настроить, чтобы доступ к gRPC сервису был только с одного порта. Порт брать из конфигурации приложения.
- Настроить, чтобы по порту gRPC нельзя было получить доступ к REST-апи

## PublicApi
- Добавить `.proto`, созданный в `InternalApi`
- Сгенерировать `gRPC-клиент` по созданному `.proto` (только клиент, без сервиса)
- Зарегистрировать клиента. URL до `InternalApi` должен браться из конфигурации приложения
- Использовать созданного клиента, для получения курсов валют (там где раньше был вызов httpClient-а теперь будет вызов gRPC клиента)
- Настроить логирование запросов `gRPC-клиента`. Используйте для этого библиотеку Audit.Net
- Доработать метод `GET /settings`, созданный в предыдущем задании. Должен возвращаться джейсон вида
  ```
  {
    "defaultCurrency": "RUB", // текущий курс валют по умолчанию из конфигурации
    "baseCurrency": "USD", // базовая валюта, относительно которой считается курс (возвращается из gRPC) 
    "newRequestsAvailable": bool, // есть ли еще доступные запросы (возвращается из gRPC)
    "currencyRoundCount": 2 // Количество знаков после запятой, до которого следует округлять значение курса валют
  }
  ```

# Задание к уроку №7

## InternalApi
- Добавить и настроить `DbContext`
- Установить схему для `DbContext` - `cur`
- Создать пустую инициальную миграцию
- Добавить таблицы, для хранения кэша `ICachedCurrencyAPI` 
- Дополнительно на свое усмотрение вы можете добавить индексы и ограничения к созданным таблицам
- Переделать сервис `ICachedCurrencyAPI` на использование базы данных, вместо сохранения на диск


## PublicApi
- Добавить и настроить `DbContext`
- Установить схему для `DbContext` - `user`
- Создать пустую инициальную миграцию
- Перенести в базу данных настройки из конфига - `defaultCurrency` и `currencyRoundCount` (курс валют по умолчанию и Количество знаков после запятой, до которого следует округлять значение курса валют)
- Добавить методы апи управления настройками
  - Изменить Валюту по умолчанию
  - Изменить Количество знаков после запятой для округления
- Добавить таблицу для хранения Избранных курсов валют. У сущности должно быть поле с названием, поле с валютой и поле с базовой валютой
```
{
  "Name": "RubToEuro",
  "Currency": "RUB",
  "BaseCurrency": "EUR"
}
```
- Настроить таблицу Избранных валют
  - Название должно быть уникальным
  - В таблице не может быть двух записей с одинаковыми валютой и базовой валютой. Т.е. если в таблице есть запись `("RubToEuro", "RUB", "EUR")`, нельзя будет добавить `("AnotherName", "RUB", "EUR")`
- Дополнительно на свое усмотрение вы можете добавить индексы и ограничения к созданным таблицам

- Для управления Избранным добавить методы в апи
  - Получить Избранное по его названию
  - Получить список всех Избранных
  - Добавить новое Избранное. В методе добавления проверять те же ограничения, которые наложены на таблицу в бд (уникальность имени, уникальность валют)
  - Изменить Избранное по его названию. В методе изменения проверять те же ограничения, которые наложены на таблицу в бд (уникальность имени, уникальность валют)
  - Удалить Избранное по его названию

- Добавить метод для получения *текущего* курса для Избранного по его названию в `PublicApi`
  - Метод должен вызывать `grpc-сервис`
  - `grpc-сервис` в `InternalApi` должен получать курс Избранного `FAV_CUR` относительно базовой валюты Избранного `FAV_CUR_BASE` по следующему алгоритму
    - Если данные в кэше устарели - получить актуальные данные
    - Получить курс для валюты `FAV_CUR` относительно базовой валюты `CACHE_BASE` из кэша (`CACHE_BASE` - базовая валюта, относительно которой строится кэш)
    - Если базовая валюта кэша `CACHE_BASE` равна базовой валюте Избранного `FAV_CUR_BASE`
      - В качестве результата вернуть полученное значение курса для `FAV_CUR` 
    - Иначе
      - Получить курс для валюты `FAV_CUR_BASE` относительно базовой валюты `CACHE_BASE` из кэша 
      - В качестве результата вернуть `FAV_CUR / FAV_CUR_BASE`
  - Пример получения курса рубля относительно евро. Базовая валюта, относительно которой строится кэш - доллар
    - `FAV_CUR` = `RUB`
    - `FAV_CUR_BASE` = `EUR`
    - `CACHE_BASE` = `USD`
    - Получаем курс для `RUB` относительно `USD` = `95.9903962843`
    - Получаем курс для `EUR` относительно `USD` = `0.9165901128` 
    - Получаем курс рубля относительно евро = `95.9903962843 / 0.9165901128 = 104.725541923` 
- Добавить метод для получения курса для Избранного по его названию в `PublicApi` *на конкретную дату* (алгоритм такой же, что и при получении текущего курса)

# Задание к уроку №9

## Завернуть PetProject в Docker
- Добавить Dockerfile для проектов `InternalApi` и `PublicApi`
- В Dockerfile-ах должно быть реализовано кэширование нугет пакетов с помощью `dotnet-subset`
- Добавить `.dockerignore` файл
- Добавить файл для docker compose
  - Описать в нем сборку двух сервисов `InternalApi` и `PublicApi`
  - Добавить `service` с базой данных
  - Использовать переменные из файла `.env`


## InternalApi
### Реализовать пересчет кэша относительно другой базовой валюты
- Создать таблицу для хранения задач для пересчета кэша `CacheTask` (название можно выбрать свое)
  - В качестве идентификатора задачи должен использоваться Guid
  - `CacheTask` должен хранить текущий статус задачи
  - Список возможных статусов 
    - `Задача создана`
    - `Задача в обработке`
    - `Задача завершена успешно`
    - `Задача завершена с ошибкой`
    - `Задача отменена`
- Добавить метод в REST-Api для пересчета кэша валют относительно новой базовой валюты
  - Должен принимать в качестве параметра новую базовую валюту `NewBaseCurrency`
  - Сохранять в БД задачу `CacheTask` на выполнение пересчета. В задаче должна сохраняться новая базовая валюта `NewBaseCurrency`
  - Добавлять статус задачи `Создана`
  - Отправлять задачу во внутреннюю очередь
  - Возвращать из метода REST-Api идентификатор созданной `CacheTask`, статус код ответа = Accepted 
- Реализовать внутреннюю очередь в виде фоновой задачи
  - Очередь должна ожидать поступающих заданий 
  - При поступлении новой задачи получать из DI сервис для обработки данной задачи
  - Вызывать метод сервиса для обработки задачи
  - При старте приложения фоновая задача должна получать из БД задачи в неокончательном статусе (статус отличный от `Завершена успешно`, `Завершена с ошибкой` и `Отменена`)
    - Если задач несколько, последнюю по дате добавления отправлять в очередь, остальным присваивать статус `Отменена`
    - Если задача одна - добавлять ее в очередь на обработку
    - Если задач нет - ничего не делать
- Реализовать сервис для пересчета кэша
  - Принимает на вход идентификатор задачи на выполнение
  - Получает из БД задачу `CacheTask` и из нее значение новой базовой валюты
  - Устанавливает задаче статус `В обработке` и сохраняет его в БД
  - Получает из базы значения кэша, сгруппированные по дате актуальности
  - Пересчитывает значение валюты по алгоритму, описанному в предыдущем задании
  - Сохраняет новые данные кэша
  - Сохраняет значение новой базовой валюты, чтобы новые запросы к апи уходили с данным значением
  - Помечает задачу как успешно завершенную
  - Если во время выполнения пересчета кэша случилась ошибка - помечает задачу как зачершенную с ошибкой и логирует ошибку
- Доработать сервис `ICachedCurrencyAPI`
  - Если кэш не протух (дата актуальности кэша соответствует запросу), то вернуть данные из кэша
  - Если кэш протух и в базе есть задача `CacheTask` в статусе `В обработке` или `Создана`, то подождать 10 секунд. 
    - Если после ожидания в БД все еще есть задача `CacheTask` в статусе `В обработке` или `Создана`, то вернуть ошибку. 
    - Если после ожидания все задачи обработались, то вызвать внеший АПИ, добавить значения в кэш и вернуть данные 
  - Если кэш протух и в базе нет задачи `CacheTask` в статусе `В обработке`, то вызвать внеший АПИ, добавить значения в кэш и вернуть данные
